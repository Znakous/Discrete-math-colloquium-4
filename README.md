# chipi-chipi-chapa-chapa

## 1. Формальные языки (Formal languages)

Суть: Множество конечных последовательностей (слов, цепочек), составленных из символов заданного конечного алфавита Σ.

Ключевые понятия:

Алфавит (Σ): Конечное множество символов (e.g., Σ = {a, b}, Σ = {0, 1}).

Слово (цепочка): Конечная последовательность символов из Σ (e.g., "abba", "001").

Пустое слово (ε): Слово длины 0.

Длина слова (|w|): Количество символов в слове.

Конкатенация слов (u·v или uv): "Склеивание" слов (e.g., "ab"·"ba" = "abba").

Язык (L): Любое подмножество множества всех возможных слов над алфавитом Σ, обозначаемого Σ*.

Примеры: L₁ = {ε, a, aa, aaa, ...} (все слова из 'a'), L₂ = {w ∈ {0,1}* | |w| четно}, L₃ = ∅ (пустой язык).

## 2. Операции над формальными языками

Конкатенация (L₁L₂): { w | w = uv, где u ∈ L₁, v ∈ L₂ }.

Пример: L₁={a}, L₂={b} => L₁L₂ = {ab}

Объединение (L₁ ∪ L₂): { w | w ∈ L₁ или w ∈ L₂ }.

Пример: L₁={a}, L₂={b} => L₁ ∪ L₂ = {a, b}

Звезда Клини (L*): Множество всех возможных конкатенаций нуля или более слов из L, включая пустое слово ε.

L* = {ε} ∪ L ∪ LL ∪ LLL ∪ ...

Пример: L={a} => L* = {ε, a, aa, aaa, aaaa, ...}

Дополнение (L̅ над Σ*): { w ∈ Σ* | w ∉ L }

Пересечение (L₁ ∩ L₂): { w | w ∈ L₁ и w ∈ L₂ }

## 3. Регулярные языки (Regular languages)

Суть: Наименьший класс языков, который:

Содержит все конечные языки (включая ∅ и {ε}).

Замкнут относительно операций объединения (∪), конкатенации (·), звезды Клини (*), а также дополнения (̅) и пересечения (∩).

Эквивалентные определения: Язык регулярен, если он может быть:

Задан регулярным выражением.

Распознан Детерминированным Конечным Автоматом (DFA).

Распознан Недетерминированным Конечным Автоматом (NFA).

Распознан Недетерминированным Конечным Автоматом с ε-переходами (ε-NFA).

Теорема Клини (Kleene’s theorem): Все эти определения эквивалентны.

## 4. Лемма о накачке (Pumping lemma)

Суть: Необходимое условие регулярности языка. Используется для доказательства нерегулярности языка (если для языка условие леммы не выполняется, он гарантированно нерегулярен). Обратное неверно!

Формулировка: Если язык L регулярен, то существует константа p (длина накачки, зависящая только от L), такая что любое слово w ∈ L длиной |w| ≥ p можно разбить на три части w = xyz, удовлетворяющие условиям:

|xy| ≤ p (первые два куска вместе не длиннее p)

|y| ≥ 1 (средний кусок не пуст)

Для любого целого k ≥ 0, слово xyᵏz также принадлежит языку L (т.е. "накачанную" часть y можно повторить сколько угодно раз или удалить (k=0)).

Как доказывать нерегулярность:

Предположим, что язык L регулярен. Тогда должна существовать константа p.

Выберите "хорошее" слово w ∈ L, такое что |w| ≥ p. Слово должно зависеть от p.

Покажите, что для любого возможного разбиения w = xyz, удовлетворяющего условиям 1 (|xy| ≤ p) и 2 (|y| ≥ 1), найдется хотя бы одно k ≥ 0 (часто k=0 или k=2), такое что xyᵏz ∉ L.

Поскольку вы нашли слово w, для которого невозможна накачка, противоречие с предположением о регулярности.

Вывод: Язык L не является регулярным.

Пример 1: Доказать, что L = {aⁿbⁿ | n ≥ 0} нерегулярен.

Предположим L регулярен. Пусть p - константа накачки.

Выберем слово w = aᵖbᵖ ∈ L, |w| = 2p ≥ p.

Рассмотрим любое разбиение w = xyz с |xy| ≤ p и |y| ≥ 1.

Так как |xy| ≤ p, то xy состоит только из символов 'a' (первые p символов - 'a'). Следовательно, y состоит из одного или более символов 'a' (y = aᵐ, m ≥ 1).

Рассмотрим слово xy⁰z = xz (удаляем y).

xz = aᵖ⁻ᵐbᵖ (так как x и z - части a-шек и все b-шки, а y удалили).

Количество 'a' (p - m) меньше количества 'b' (p), так как m ≥ 1. Значит, xz ∉ L (требуется равное количество).

Нашли k=0, при котором xy⁰z ∉ L. Противоречие.

Вывод: L нерегулярен.

**Пример 2: Доказать, что L = { ww | w ∈ {0,1}* } (палиндромы четной длины) нерегулярен.**

Предположим L регулярен. Пусть p - константа.

Выберем слово w = 0ᵖ1 0ᵖ1 ∈ L (|w| = 2p+2 ≥ p).

Рассмотрим любое разбиение w = xyz с |xy| ≤ p и |y| ≥ 1.

|xy| ≤ p, значит xy лежит целиком в первой части слова, состоящей из p нулей и одной единицы: 0ᵖ1. Следовательно, y состоит только из нулей (y = 0ᵐ, m ≥ 1) и находится в блоке из p нулей.

Рассмотрим слово xy²z.

xyyz = x y y z = [0ᵏ] [0ᵐ] [0ᵐ] [0ᵖ⁻ᵏ⁻ᵐ 1 0ᵖ1] = 0ᵏ⁺ᵐ⁺ᵐ 0ᵖ⁻ᵏ⁻ᵐ 1 0ᵖ1 = 0ᵖ⁺ᵐ 1 0ᵖ1

Исходное слово было 0ᵖ1 0ᵖ1. После накачки первая половина стала 0ᵖ⁺ᵐ1, а вторая осталась 0ᵖ1. Так как m ≥ 1, p+m > p. Значит, первая половина 0ᵖ⁺ᵐ1 не равна второй половине 0ᵖ1. Следовательно, xyyz ∉ L.

Нашли k=2, при котором xy²z ∉ L. Противоречие.

Вывод: L нерегулярен.

## 5. Регулярные выражения (Regular expressions)

Суть: Формальный способ описания регулярных языков с помощью алфавита Σ и операций: объединение (+), конкатенация (· или просто последовательность), звезда Клини (*), а также констант: ∅ (пустой язык), ε (язык, содержащий только пустое слово), a (язык, содержащий только символ 'a').

Рекурсивное определение:

∅, ε, a (для каждого a ∈ Σ) - регулярные выражения.

Если R и S - регулярные выражения, то (R + S), (R·S), (R*) - регулярные выражения.

Семантика (язык, задаваемый РВ):

L(∅) = ∅

L(ε) = {ε}

L(a) = {a}

L(R + S) = L(R) ∪ L(S)

L(R·S) = L(R)·L(S)

L(R) = (L(R))

Примеры:

(a + b)* = все слова из 'a' и 'b' (включая ε).

a(a + b)*b = слова, начинающиеся на 'a' и заканчивающиеся на 'b'.

(aa + bb)* = слова четной длины, состоящие из пар 'aa' и 'bb'.

## 6. Детерминированный конечный автомат (DFA)

Формальное определение: Кортеж A = (Q, Σ, δ, q₀, F)

Q: Конечное множество состояний.

Σ: Конечный входной алфавит.

δ: Q × Σ → Q - функция переходов. Для каждого состояния и входного символа однозначно определяет следующее состояние.

q₀ ∈ Q: Начальное состояние.

F ⊆ Q: Множество допускающих (конечных) состояний.

Суть работы:

Начинаем в состоянии q₀.

Читаем входное слово посимвольно слева направо.

Для каждого прочитанного символа a переходим в состояние δ(q, a), где q - текущее состояние.

После прочтения всего слова, автомат останавливается.

Слово принимается, если автомат остановился в состоянии, принадлежащем F (q ∈ F).

Ключевая характеристика: Детерминизм. В каждый момент времени для текущего состояния и текущего символа существует ровно один переход. Нет ε-переходов.

Пример: Автомат, принимающий слова с четным количеством '1'. Состояния: q₀ (четное, начальное и допускающее), q₁ (нечетное). Переходы: δ(q₀, 0)=q₀, δ(q₀, 1)=q₁, δ(q₁, 0)=q₁, δ(q₁, 1)=q₀.

## 7. Недетерминированный конечный автомат (NFA)

Формальное определение: Кортеж A = (Q, Σ, δ, q₀, F) (компоненты те же, что у DFA).

δ: Q × Σ → P(Q) (Множество подмножеств Q) - функция переходов. Для каждого состояния и входного символа определяет множество возможных следующих состояний (может быть 0, 1 или несколько).

Суть работы:

Начинаем в состоянии q₀.

Читаем входное слово посимвольно слева направо.

Для каждого прочитанного символа a автомат одновременно переходит во все состояния из множества δ(q, a), где q - текущее состояние (возникает "множество текущих состояний").

Возможны "тупики" (δ(q, a) = ∅).

После прочтения всего слова, автомат останавливается.

Слово принимается, если хотя бы одна из возможных последовательностей переходов (путей) привела автомат в состояние, принадлежащее F.

Ключевая характеристика: Недетерминизм. Возможность иметь несколько переходов по одному символу из одного состояния, а также отсутствие переходов. Нет ε-переходов.

Пример: Автомат, принимающий слова, оканчивающиеся на "01". Состояния: q₀, q₁, q₂ (F). Переходы: δ(q₀, 0)={q₀, q₁}, δ(q₀, 1)={q₀}, δ(q₁, 0)=∅, δ(q₁, 1)={q₂}, δ(q₂, 0)=∅, δ(q₂, 1)=∅. На слове "001": Пути (q₀->q₀->q₀->q₀) и (q₀->q₀->q₁->q₂). Один путь (через q₂) попал в F => слово принимается.

## 8. Построение подмножеств (Powerset construction)

Суть: Алгоритм преобразования любого NFA в эквивалентный DFA, распознающий точно такой же язык.

Мотивация: DFA проще моделировать на компьютере, так как в каждый момент есть только одно текущее состояние.

Конструкция: Пусть дан NFA N = (Q_N, Σ, δ_N, q₀_N, F_N). Построим DFA D = (Q_D, Σ, δ_D, q₀_D, F_D):

Q_D = P(Q_N) (Множество всех подмножеств состояний NFA).

q₀_D = {q₀_N} (Начальное состояние DFA - множество, содержащее только начальное состояние NFA).

F_D = { S ∈ Q_D | S ∩ F_N ≠ ∅ } (Состояние DFA допускающее, если оно содержит хотя бы одно допускающее состояние NFA).

δ_D(S, a) = ⋃_{q ∈ S} δ_N(q, a) (Для множества состояний S DFA и символа a, следующее состояние DFA - это объединение всех состояний NFA, в которые можно попасть из любого состояния q ∈ S по символу a в NFA).

Результат: Полученный DFA D эквивалентен исходному NFA N (L(D) = L(N)).

Замечание: Число состояний DFA в худшем случае экспоненциально (2ⁿ) относительно числа состояний NFA (n). Не все состояния достижимы.

## 9. ε-НКА (Epsilon-NFA)

Формальное определение: Кортеж A = (Q, Σ, δ, q₀, F) (компоненты те же).

δ: Q × (Σ ∪ {ε}) → P(Q) - функция переходов. Позволяет переходить по входному символу или по пустой строке ε (без чтения символа из входной строки).

Суть работы: Аналогична NFA, но автомат может совершать спонтанные переходы (ε-переходы) в любое время, не перемещая указатель на входной ленте.

ε-замыкание (ε-CLOSURE(q)): Множество всех состояний, достижимых из состояния q только по ε-переходам (включая само q).

Расширенная функция переходов: Для множества состояний R и символа a (или ε), определяется как множество состояний, достижимых из любого состояния r ∈ R по символу a (или ε) с последующим применением ε-замыкания.

Пример шага: Из состояния q по символу a можно перейти в состояния δ(q, a). Затем из каждого из этих состояний можно сделать ε-переходы (ε-CLOSURE). Это и будет результат перехода по a из q.

Прием слова: Слово w принимается, если существует путь по символам w (с учетом вставок ε-переходов между ними), ведущий из q₀ в состояние из F.

## 10. Построение НКА из ε-НКА

Суть: Алгоритм устранения ε-переходов из ε-NFA для получения эквивалентного NFA (без ε-переходов).

Конструкция: Пусть дан ε-NFA E = (Q_E, Σ, δ_E, q₀_E, F_E). Построим NFA N = (Q_N, Σ, δ_N, q₀_N, F_N):

Q_N = Q_E (Состояния те же).

q₀_N = ε-CLOSURE(q₀_E) (Начальное состояние NFA - это ε-замыкание начального состояния ε-NFA).

F_N = { q ∈ Q_N | ε-CLOSURE(q) ∩ F_E ≠ ∅ } (Состояние допускающее в NFA, если из него по ε-переходам можно достичь хотя бы одного допускающего состояния в ε-NFA).

δ_N(q, a) = ε-CLOSURE( ⋃_{p ∈ ε-CLOSURE(q)} δ_E(p, a) ) (Чтобы определить переход из q по символу a в NFA: 1) Найти все состояния p, достижимые из q по ε-переходам (ε-CLOSURE(q)). 2) Из каждого p найти все состояния, достижимые по символу a в ε-NFA (δ_E(p, a)). 3) Взять объединение этих состояний. 4) Найти ε-замыкание этого объединения).

Результат: Полученный NFA N эквивалентен исходному ε-NFA E (L(N) = L(E)).

## 11. Построение Томпсона (Thompson’s construction)

Суть: Рекурсивный алгоритм построения ε-NFA, распознающего язык, заданный регулярным выражением. Доказывает одну часть теоремы Клини (РВ -> ε-NFA).

Базис:

∅: ε-NFA для ∅ (Начальное состояние не соединено с допускающим).

ε: ε-NFA для ε (Начальное состояние соединено ε-переходом с допускающим).

a (символ): ε-NFA для a (Начальное состояние соединено переходом по 'a' с допускающим).

Индукция:

R + S (объединение): ε-NFA для R+S Создаем новое начальное и новое конечное состояние. Из нового начального - ε-переходы в начальные состояния автоматов для R и S. Из конечных состояний автоматов для R и S - ε-переходы в новое конечное состояние.

R·S (конкатенация): ε-NFA для RS Конечное состояние автомата для R соединяем ε-переходом с начальным состоянием автомата для S. Начальное состояние нового автомата = начальное R. Конечное состояние нового автомата = конечное S.

R (звезда Клини):* ε-NFA для R* Создаем новое начальное и новое конечное состояние. Из нового начального: ε-переход в начальное R и ε-переход в новое конечное. Из конечного R: ε-переход в начальное R (петля) и ε-переход в новое конечное.

Результат: Для любого РВ строится ε-NFA с одним начальным и одним допускающим состоянием, распознающий тот же язык.

## 12. Теорема Клини (Kleene’s theorem)

Формулировка: Следующие четыре класса языков совпадают:

Языки, распознаваемые Детерминированными Конечными Автоматами (DFA).

Языки, распознаваемые Недетерминированными Конечными Автоматами (NFA).

Языки, распознаваемые Недетерминированными Конечными Автоматами с ε-переходами (ε-NFA).

Языки, описываемые Регулярными Выражениями (Regular Expressions).

Доказательство (схема): Доказывается цепочка включений:

DFA ⊆ NFA ⊆ ε-NFA: Очевидно (DFA - частный случай NFA; NFA - частный случай ε-NFA без ε-переходов).

ε-NFA ⊆ NFA: Построение НКА из ε-НКА (пункт 10).

NFA ⊆ DFA: Построение подмножеств (пункт 8).

DFA ⊆ РВ: Строится РВ для языка, состоящего из слов, переводящих DFA из состояния i в состояние j, обходя только состояния с номерами <= k (динамическое программирование, метод удаления состояний).

РВ ⊆ ε-NFA: Построение Томпсона (пункт 11).

## 13. Упорядоченные размещения (Ordered arrangements)

Суть: Любое расположение элементов множества в определенном порядке.

Ключевое: Порядок важен. Разные порядки одних и тех же элементов - разные размещения.

Пример: Множество S={A,B,C}. Размещения: (A,B,C), (A,C,B), (B,A,C), (B,C,A), (C,A,B), (C,B,A).

## 14. Перестановки (Permutations)

Суть: Биективное отображение множества из n элементов на себя. Эквивалентно всем возможным упорядоченным размещениям всех n элементов без повторений.

Число перестановок: P(n) = n! = n × (n-1) × (n-2) × ... × 2 × 1.

Пример: S={1,2,3}. Перестановки: (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1). n=3, P(3)=3!=6.

## 15. k-перестановки (k-permutations, Размещения без повторений)

Суть: Упорядоченная выборка k различных элементов из множества из n элементов (k ≤ n). Порядок важен.

Число k-перестановок: P(n, k) = n! / (n-k)! = n × (n-1) × (n-2) × ... × (n-k+1).

Пример: S={A,B,C,D}, выбрать 2 элемента. Варианты: (A,B), (A,C), (A,D), (B,A), (B,C), (B,D), (C,A), (C,B), (C,D), (D,A), (D,B), (D,C). n=4, k=2, P(4,2)=4*3=12.

## 16. Циклические перестановки (Cyclic permutations)

Суть: Перестановки, которые считаются одинаковыми, если одну можно получить из другой циклическим сдвигом. Представляют расположение элементов по кругу.

Число циклических перестановок: (n-1)!.

Обоснование: Всего линейных перестановок n!. Для каждой циклической перестановки есть n линейных представлений (сдвигов). Значит, число циклов: n! / n = (n-1)!.

Пример: S={A,B,C}. Циклические перестановки: (A->B->C->A) и (A->C->B->A) (эквивалентно (B->C->A->B), (C->A->B->C) для первого цикла). n=3, (3-1)! = 2.

## 17. Неупорядоченные размещения (Unordered arrangements)

Суть: Выбор элементов из множества без учета порядка их расположения. Это сочетания.

Ключевое: Порядок не важен. Множества {A,B} и {B,A} - это одно и то же сочетание.

## 18. k-сочетания (k-combinations, Сочетания без повторений)

Суть: Выбор k различных элементов из множества из n элементов (k ≤ n) без учета порядка.

Число k-сочетаний: C(n, k) = n! / (k!(n-k)!) = (n choose k).

Связь с k-перестановками: P(n, k) = C(n, k) * k! (Сначала выбираем какие k элементов (сочетание), затем упорядочиваем их (k! способов)).

Пример: S={A,B,C,D}, выбрать 2 элемента. Варианты: {A,B}, {A,C}, {A,D}, {B,C}, {B,D}, {C,D}. n=4, k=2, C(4,2)=6.

## 19. Мультимножества (Multisets)

Суть: Обобщение понятия множества, в котором элементы могут встречаться несколько раз (иметь кратность). Порядок элементов не важен.

Обозначение: { a₁^{m₁}, a₂^{m₂}, ..., aₖ^{mₖ} }, где mᵢ - кратность элемента aᵢ (сколько раз он встречается).

Мощность: |M| = m₁ + m₂ + ... + mₖ (общее количество элементов с учетом кратностей).

Пример: M = {a, a, a, b, b, c} = {a³, b², c¹}, |M| = 6.

## 20. Перестановки мультимножеств (Permutations of multisets)

Суть: Количество различных последовательностей (слов), которые можно составить из элементов мультимножества.

Формула: Если мультимножество имеет общую мощность n, а его элементы имеют кратности k₁, k₂, ..., kₘ (n = k₁ + k₂ + ... + kₘ), то число различных перестановок: n! / (k₁! k₂! ... kₘ!).

Обоснование: Если бы все элементы были различны, было бы n! перестановок. Но так как элементы типа i неразличимы и их можно переставить между собой kᵢ! способами, не меняя внешнего вида перестановки, мы делим n! на k₁! k₂! ... kₘ!.

Пример: M = {A,A,B} (k₁=2 для A, k₂=1 для B, n=3). Перестановки: AAB, ABA, BAA. Формула: 3! / (2! * 1!) = 6 / 2 = 3.

## 21. Сочетания с повторениями (Combinations of infinite multisets)

Суть: Выбор k элементов из m различных типов элементов, причем элементов каждого типа имеется неограниченное количество (или достаточно много). Порядок выбранных элементов не важен.

Формула: CR(m, k) = C(k + m - 1, k) = C(k + m - 1, m - 1) = (k + m - 1)! / (k! (m - 1)!).

Интерпретация "Stars and Bars": Задача эквивалентна распределению k неразличимых звезд (*) по m различимым корзинам (типам) с помощью (m-1) неразличимой перегородки (|). Число способов расставить (m-1) перегородку среди (k + m - 1) позиций (k звезд + m-1 перегородок) равно C(k + m - 1, k) или C(k + m - 1, m-1).

Пример: Выбрать 3 пирожных из 4 видов (m=4, k=3). CR(4,3) = C(3+4-1, 3) = C(6,3)=20. Примеры выборок: (3,0,0,0), (2,1,0,0), (1,1,1,0) и т.д. (где числа - количество взятых пирожных каждого вида).

## 22. Композиции (Compositions)

Суть: Представление целого положительного числа n в виде суммы упорядоченной последовательности положительных целых чисел (частей). Порядок слагаемых важен!

Число композиций n: 2ⁿ⁻¹.

Обоснование: Между n единицами, стоящими в ряд, есть (n-1) промежуток. В каждый промежуток можно либо поставить "+" (объединить единицы), либо "," (разделить на части). Каждый выбор даст уникальную композицию. Вариантов выбора: 2ⁿ⁻¹.

Пример: n=3. Композиции: 3, 1+2, 2+1, 1+1+1. Всего 4 = 2³⁻¹.

## 23. Разбиения множества (Set partitions)

Суть: Представление множества S из n элементов в виде объединения непустых, попарно непересекающихся подмножеств, называемых блоками (или частями). Порядок блоков не важен, порядок элементов внутри блока не важен.

Пример: S={1,2,3}. Разбиения:

{{1,2,3}} (1 блок)

{{1,2},{3}}, {{1,3},{2}}, {{1},{2,3}} (2 блока)

{{1},{2},{3}} (3 блока)

## 24. Числа Стирлинга второго рода (Stirling numbers of the second kind)

Обозначение: S(n, k)

Суть: Количество способов разбить множество из n элементов ровно на k непустых, неупорядоченных блоков.

Рекуррентное соотношение:

S(n, k) = k * S(n-1, k) + S(n-1, k-1) для n > 0, k > 0.

Граничные условия:

S(n, 0) = 0 при n > 0

S(0, k) = 0 при k > 0

S(0, 0) = 1

S(n, n) = 1

S(n, 1) = 1

Интерпретация рекурренты: Фиксируем элемент 'n'. Он может:

Образовать новый блок сам по себе: Тогда оставшиеся n-1 элементов нужно разбить на k-1 блоков: S(n-1, k-1) способов.

Быть добавлен в один из существующих k блоков: Оставшиеся n-1 элементов уже разбиты на k блоков, и элемент 'n' можно добавить в любой из этих k блоков: k * S(n-1, k) способов.

Пример: S(3,2) = 3 (Разбиения {{1,2},{3}}, {{1,3},{2}}, {{1},{2,3}}). По формуле: S(3,2) = 2*S(2,2) + S(2,1) = 2*1 + 1 = 3.

## 25. Числа Белла (Bell numbers)

Обозначение: B(n)

Суть: Общее число всех возможных разбиений множества из n элементов (на любое число блоков от 1 до n).

Формула через числа Стирлинга: B(n) = Σ_{k=0}^{n} S(n, k) (Сумма по всем возможным k).

Рекуррентное соотношение:

B(n) = Σ_{k=0}^{n-1} C(n-1, k) * B(k) для n > 0.

B(0) = 1.

Интерпретация рекурренты: Фиксируем элемент 'n'. Он будет в блоке размера (m+1), где m - количество других элементов в этом блоке. Эти m элементов выбираются из оставшихся n-1 элементов: C(n-1, m) способов. Оставшиеся (n-1-m) элементов образуют некоторое разбиение: B(n-1-m) способов. Суммируем по всем m от 0 до n-1: B(n) = Σ_{m=0}^{n-1} C(n-1, m) * B(n-1-m) = Σ_{k=0}^{n-1} C(n-1, k) * B(k) (где k = n-1-m).

Пример: B(3) = S(3,1) + S(3,2) + S(3,3) = 1 + 3 + 1 = 5. По рекурренте: B(3) = C(2,0)B(0) + C(2,1)B(1) + C(2,2)B(2) = 1*1 + 2*1 + 1*2 = 1 + 2 + 2 = 5.

## 26. Разбиения числа (Integer partitions)

Суть: Представление целого положительного числа n в виде суммы положительных целых чисел (частей), где порядок слагаемых не важен. Части обычно записывают в невозрастающем порядке.

Обозначение: p(n) - число разбиений числа n.

Пример: n=4.

4

3+1

2+2

2+1+1

1+1+1+1

p(4) = 5.

Ключевое отличие от композиций: Порядок слагаемых не важен. Поэтому 3+1 и 1+3 - это одно и то же разбиение числа 4.

## 27. Принцип включения-исключения (PIE) (Principle of Inclusion-Exclusion)

Суть: Формула для вычисления мощности объединения конечного числа конечных множеств, которая корректно учитывает перекрытия между множествами.

Формула для двух множеств: |A ∪ B| = |A| + |B| - |A ∩ B|

Формула для трех множеств: |A ∪ B ∪ C| = |A| + |B| + |C| - |A ∩ B| - |A ∩ C| - |B ∩ C| + |A ∩ B ∩ C|

Общая формула (для n множеств):
|A₁ ∪ A₂ ∪ ... ∪ Aₙ| =
Σ|Aᵢ| - Σ|Aᵢ ∩ Aⱼ| + Σ|Aᵢ ∩ Aⱼ ∩ Aₖ| - ... + (-1)ᵏ⁺¹ Σ|Aᵢ₁ ∩ Aᵢ₂ ∩ ... ∩ Aᵢₖ| + ... + (-1)ⁿ⁺¹ |A₁ ∩ A₂ ∩ ... ∩ Aₙ|

Первая сумма (Σ|Aᵢ|) по всем i.

Вторая сумма (Σ|Aᵢ ∩ Aⱼ|) по всем парам i < j.

Третья сумма (Σ|Aᵢ ∩ Aⱼ ∩ Aₖ|) по всем тройкам i < j < k.

...

Последний член (-1)ⁿ⁺¹ |A₁ ∩ A₂ ∩ ... ∩ Aₙ| для пересечения всех n множеств.

Применение: Подсчет количества элементов, обладающих хотя бы одним из свойств (Aᵢ), или, наоборот, не обладающих ни одним из свойств (дополнение объединения).

Пример: Сколько чисел от 1 до 100 делятся на 2 или на 3?

A = {числа, дел. на 2}, |A| = floor(100/2)=50

B = {числа, дел. на 3}, |B| = floor(100/3)=33

A ∩ B = {числа, дел. на 6}, |A ∩ B| = floor(100/6)=16

|A ∪ B| = 50 + 33 - 16 = 67.

## 28. Числа Каталана (Catalan numbers)

Обозначение: Cₙ

Суть: Последовательность натуральных чисел, возникающая в огромном количестве комбинаторных задач подсчета.

Формулы:

Cₙ = (1/(n+1)) * (2n choose n) = (1/(n+1)) * (2n)! / (n! * n!)

Cₙ = (2n choose n) - (2n choose n-1) (Разность биномиальных коэффициентов)

Рекуррентное соотношение:

Cₙ = Σ_{i=0}^{n-1} Cᵢ * C_{n-1-i} для n ≥ 1, C₀ = 1.

(Сумма произведений чисел Каталана с индексами, дающими в сумме n-1)

Примеры задач:

Число корректных скобочных последовательностей длины 2n (n пар скобок). ()(), (()) для n=2: C₂=2.

Число путей Дика из (0,0) в (2n,0) шагами (1,1) и (1,-1), не опускающихся ниже оси OX.

Число полных бинарных деревьев с n+1 листьями (или n внутренними вершинами).

Число способов разбить выпуклый (n+2)-угольник на треугольники непересекающимися диагоналями.

Число способов треугольного произведения n+1 матриц.

Первые числа: C₀=1, C₁=1, C₂=2, C₃=5, C₄=14, C₅=42.

## 29. Рекуррентные соотношения (Recurrence relations)

Суть: Уравнения или неравенства, выражающие n-й член последовательности {aₙ} через один или несколько предыдущих членов (aₙ₋₁, aₙ₋₂, ..., aₙ₋ₖ) и, возможно, через саму переменную n. Определяют последовательность рекурсивно.

Порядок: Определяется максимальным отставанием (k). aₙ = f(aₙ₋₁, aₙ₋₂, ..., aₙ₋ₖ).

Начальные условия: Значения первых k членов последовательности (a₀, a₁, ..., aₖ₋₁), необходимые для однозначного определения всей последовательности.

Примеры:

Фибоначчи: aₙ = aₙ₋₁ + aₙ₋₂ (порядок 2), a₀=0, a₁=1.

Факториал: aₙ = n * aₙ₋₁ (порядок 1), a₀=1.

Числа Каталана: Cₙ = Σ_{i=0}^{n-1} Cᵢ C_{n-1-i} (порядок n, линейное неоднородное? Нет, нелинейное!).

Классификация:

Линейные (Linear): aₙ = c₁(n)aₙ₋₁ + c₂(n)aₙ₋₂ + ... + cₖ(n)aₙ₋ₖ + f(n)

Однородные (Homogeneous): f(n) = 0.

С постоянными коэффициентами (Constant Coefficients): c₁, c₂, ..., cₖ - константы (не зависят от n).

Неоднородные (Nonhomogeneous): f(n) ≠ 0.

## 30. Решение ЛОРС с постоянными коэффициентами (характеристическим уравнением)

Метод: Применим к линейным однородным рекуррентным соотношениям с постоянными коэффициентами (ЛОРСПК) вида:
aₙ = c₁aₙ₋₁ + c₂aₙ₋₂ + ... + cₖaₙ₋ₖ, где c₁, c₂, ..., cₖ - константы, cₖ ≠ 0.

Алгоритм:

Характеристическое уравнение: rᵏ - c₁rᵏ⁻¹ - c₂rᵏ⁻² - ... - cₖ = 0.

Найти корни: Найти корни r₁, r₂, ..., rₘ этого уравнения (действительные или комплексные) с их кратностями s₁, s₂, ..., sₘ (s₁ + s₂ + ... + sₘ = k).

Фундаментальная система решений:

Если корень rᵢ действительный кратности sᵢ, то ему соответствуют решения: rᵢⁿ, n rᵢⁿ, n² rᵢⁿ, ..., nˢⁱ⁻¹ rᵢⁿ.

Если корень rⱼ = α + βi комплексный кратности sⱼ (а значит, есть комплексно сопряженный корень r̄ⱼ = α - βi той же кратности), то им соответствуют действительные решения: ρⁿ cos(nθ), ρⁿ sin(nθ), n ρⁿ cos(nθ), n ρⁿ sin(nθ), ..., nˢʲ⁻¹ ρⁿ cos(nθ), nˢʲ⁻¹ ρⁿ sin(nθ), где ρ = |rⱼ| = √(α²+β²), θ = arg(rⱼ) = atan2(β, α).

Общее решение: Линейная комбинация всех фундаментальных решений с произвольными константами:
aₙ = (A₁₀ + A₁₁n + ... + A₁,ₛ₁₋₁n^{s₁-1}) r₁ⁿ + ... + (Aₘ₀ + ... + Aₘ,ₛₘ₋₁n^{sₘ-1}) rₘⁿ [+ соответствующие действительные части для комплексных корней].

Найти константы: Использовать начальные условия (k штук: a₀, a₁, ..., aₖ₋₁) для нахождения значений констант Aᵢⱼ.

Пример: aₙ = 5aₙ₋₁ - 6aₙ₋₂ (n≥2), a₀=1, a₁=2.

Хар. ур-е: r² - 5r + 6 = 0.

Корни: r₁=2, r₂=3 (действ. простые).

Общее решение: aₙ = A * 2ⁿ + B * 3ⁿ.

Нач. усл.:

n=0: a₀ = A*2⁰ + B*3⁰ = A + B = 1

n=1: a₁ = A*2¹ + B*3¹ = 2A + 3B = 2

Решаем систему: A+B=1, 2A+3B=2 => A=1, B=0.

Решение: aₙ = 2ⁿ.

## 31. Производящие функции (Generating functions)

Суть (Обыкновенная ПФ): Формальный степенной ряд G(x) = a₀ + a₁x + a₂x² + a₃x³ + ... = Σ_{n=0}^{∞} aₙ xⁿ, где коэффициенты aₙ образуют последовательность, которую мы изучаем.

Назначение:

Представить последовательность компактно (одной функцией).

Решать рекуррентные соотношения.

Доказывать тождества.

Решать комбинаторные задачи подсчета.

Операции: С ПФ можно работать как с формальными рядами: складывать, умножать, дифференцировать, интегрировать. Результат операций соответствует операциям над последовательностями.

Примеры:

Последовательность (1,1,1,1,...): G(x) = 1 + x + x² + x³ + ... = 1/(1-x) (геом. прогрессия).

Последовательность (1,2,3,4,...): G(x) = 1 + 2x + 3x² + 4x³ + ... = 1/(1-x)² (производная от 1/(1-x) или (1/(1-x)) * (1/(1-x)) для конволюции (1,1,1,...)*(1,1,1,...)).

## 32. Степенные ряды (Power series)

Суть: Ряд вида F(x) = c₀ + c₁(x - a) + c₂(x - a)² + c₃(x - a)³ + ... = Σ_{n=0}^{∞} cₙ (x - a)ⁿ, где a - центр ряда, cₙ - коэффициенты.

Связь с ПФ: Обыкновенные производящие функции - это степенные ряды с центром a=0: G(x) = Σ cₙ xⁿ.

Радиус сходимости: В математическом анализе степенной ряд сходится в интервале |x - a| < R. В комбинаторике и дискретной математике ПФ часто рассматриваются как формальные степенные ряды (без учета сходимости), где важны только коэффициенты.

## 33. Решение линейных рекуррентных соотношений с помощью ПФ

Метод: Применим к линейным рекуррентным соотношениям (однородным и неоднородным) с постоянными коэффициентами.

Алгоритм:

Записать ПФ G(x) = Σ aₙ xⁿ для последовательности {aₙ}.

Используя рекуррентное соотношение и начальные условия, выразить G(x) через саму себя. Это обычно включает:

Подстановку рекуррентного соотношения для aₙ (n ≥ k) в ряд.

Выделение членов ряда для n < k (которые известны из начальных условий).

Алгебраические преобразования (сложение, вычитание рядов).

Решить полученное уравнение относительно G(x). Получить G(x) в замкнутом виде (как рациональную функцию, обычно).

Разложить полученную замкнутую форму G(x) в степенной ряд (часто методом разложения на простейшие дроби или используя известные разложения).

Коэффициент при xⁿ в полученном разложении и будет искомым решением aₙ.

Пример (Фибоначчи): aₙ = aₙ₋₁ + aₙ₋₂ (n≥2), a₀=0, a₁=1.

G(x) = a₀ + a₁x + a₂x² + a₃x³ + ... = 0 + 1*x + a₂x² + a₃x³ + ...

Запишем рекурренту для n≥2: aₙxⁿ = aₙ₋₁xⁿ + aₙ₋₂xⁿ.
Суммируем для n от 2 до ∞:
Σ_{n=2}^{∞} aₙxⁿ = Σ_{n=2}^{∞} aₙ₋₁xⁿ + Σ_{n=2}^{∞} aₙ₋₂xⁿ
Левая часть: G(x) - a₀ - a₁x = G(x) - x
Правая часть: x Σ_{n=2}^{∞} aₙ₋₁xⁿ⁻¹ + x² Σ_{n=2}^{∞} aₙ₋₂xⁿ⁻² = x Σ_{m=1}^{∞} aₘxᵐ + x² Σ_{k=0}^{∞} aₖxᵏ = x(G(x) - a₀) + x²G(x) = xG(x) + x²G(x)
Уравнение: G(x) - x = xG(x) + x²G(x)

Решаем: G(x) - xG(x) - x²G(x) = x => G(x)(1 - x - x²) = x => G(x) = x / (1 - x - x²)

Раскладываем x / (1 - x - x²) на простейшие. Корни знаменателя: r₁=(1+√5)/2, r₂=(1-√5)/2.
G(x) = x / ((1 - r₁x)(1 - r₂x)) = A/(1-r₁x) + B/(1-r₂x)
Находим A, B: A = 1/(r₁-r₂) = 1/√5, B = -1/√5 (проверить!).
G(x) = (1/√5) [1/(1-r₁x) - 1/(1-r₂x)] = (1/√5) [ Σ (r₁ⁿxⁿ) - Σ (r₂ⁿxⁿ) ] = Σ (1/√5)(r₁ⁿ - r₂ⁿ) xⁿ

Значит, aₙ = (1/√5) ( ((1+√5)/2)ⁿ - ((1-√5)/2)ⁿ ) (Формула Бине).

## 34. Решение комбинаторных задач с помощью ПФ

Суть: Сопоставить комбинаторным объектам (или способам их построения) производящие функции. Операции над ПФ (сложение, умножение) соответствуют комбинаторным операциям (объединение непересекающихся множеств, декартово произведение, композиция).

Виды ПФ для комбинаторики:

Обыкновенная (Ordinary): Для задач, где порядок не важен (сочетания). Вес объекта = 1. G(x) = Σ cₙ xⁿ, cₙ - число объектов размера n.

Экспоненциальная (Exponential): Для задач, где порядок важен (перестановки). G(x) = Σ cₙ xⁿ / n!.

Основной принцип:

ПФ для одного объекта: Если объект имеет размер k, его ПФ часто xᵏ (для обыкновенной) или xᵏ/k! (для экспоненциальной).

ПФ для множества объектов: Если множество объектов = объединение непересекающихся классов, ПФ = сумма ПФ классов.

ПФ для композиции объектов: Если объект строится как упорядоченная пара (кортеж) независимых подобъектов, ПФ = произведение ПФ подобъектов.

ПФ для последовательностей объектов: Если объект - это последовательность (0 или более) объектов некоторого типа T, ПФ = 1 / (1 - G_T(x)) (где G_T(x) - ПФ для типа T), при условии, что последовательность непуста, то G_T(x)/(1 - G_T(x)).

Пример (Число способов набрать сумму в n рублей монетами 1р, 2р, 5р):

Выбор монеты 1р: x⁰ + x¹ + x² + x³ + ... = 1/(1-x) (0,1,2,... монет)

Выбор монеты 2р: x⁰ + x² + x⁴ + x⁶ + ... = 1/(1-x²)

Выбор монеты 5р: x⁰ + x⁵ + x¹⁰ + x¹⁵ + ... = 1/(1-x⁵)

Так как выборы монет разных типов независимы, общая ПФ:
G(x) = (1/(1-x)) * (1/(1-x²)) * (1/(1-x⁵))

Коэффициент при xⁿ в разложении G(x) дает число способов набрать сумму n.

## 35. Операторы и аннигиляторы (Operators and annihilators)

Оператор сдвига (E): Оператор, действующий на последовательность: E[aₙ] = aₙ₊₁.

Аннигилятор: Полином от оператора сдвига φ(E), который обнуляет заданную последовательность {bₙ}, то есть φ(E)[bₙ] = 0 для всех n.

Нахождение аннигиляторов:

Последовательность-константа (bₙ = c): (E - 1)[c] = c - c = 0 => аннигилятор (E - 1).

Геометрическая прогрессия (bₙ = rⁿ): (E - r)[rⁿ] = rⁿ⁺¹ - r*rⁿ = 0 => аннигилятор (E - r).

Многочлен степени d (bₙ = P_d(n)): (E - 1)^{d+1}[P_d(n)] = 0. Пример: bₙ = n (линейный). (E-1)²[n] = (E-1)[(n+1) - n] = (E-1)[1] = 1 - 1 = 0. Аннигилятор (E-1)².

Комбинация: Если {bₙ} = rⁿ * P_d(n), то аннигилятор (E - r)^{d+1}.

Сумма: Если L₁ аннигилирует {bₙ}, а L₂ аннигилирует {cₙ}, то L₁L₂ аннигилирует {bₙ + cₙ} (если L₁ и L₂ коммутируют, что верно для полиномов от E).

## 36. Решение линейных рекуррентных соотношений с помощью аннигиляторов

Метод: Применим к линейным неоднородным рекуррентным соотношениям с постоянными коэффициентами.

Алгоритм:

Найти аннигилятор L₁ для однородной части. Однородная часть рекурренты aₙ = c₁aₙ₋₁ + ... + cₖaₙ₋ₖ имеет характеристический полином rᵏ - c₁rᵏ⁻¹ - ... - cₖ. Аннигилятор для однородного решения: L₁ = Eᵏ - c₁Eᵏ⁻¹ - ... - cₖ (или φ(E), где φ(r) - хар. полином).

Найти аннигилятор L₂ для неоднородной части f(n). Используя правила из п.35, найти оператор L₂, такой что L₂[f(n)] = 0.

Общий аннигилятор: L = L₂ L₁ (или L₁ L₂, операторы коммутируют). Этот оператор аннигилирует всю правую часть рекурренты (однородную часть + f(n)) и, следовательно, аннигилирует и левую часть aₙ. Получаем: L[aₙ] = 0.

Решить полученное однородное уравнение: Уравнение L[aₙ] = 0 является линейным однородным рекуррентным уравнением, но более высокого порядка, чем исходное. Решить его стандартным методом характеристического уравнения (п.30). Получим общее решение в виде линейной комбинации фундаментальных решений: aₙ = Σ Cᵢ bᵢ(n).

Найти частное решение исходного уравнения (опционально, но обычно входит в общее): Полученное общее решение aₙ = Σ Cᵢ bᵢ(n) для уравнения L[aₙ]=0 включает в себя как решения однородного уравнения (L₁[aₙ]=0), так и частные решения неоднородного. Оно и будет общим решением исходного неоднородного уравнения.

Найти константы: Использовать начальные условия исходной задачи для нахождения констант Cᵢ.

Пример: aₙ - 2aₙ₋₁ = 3ⁿ (n≥1), a₀=1.

Однородная часть: aₙ - 2aₙ₋₁ = 0. Хар. ур-е: r - 2 = 0. Аннигилятор L₁ = E - 2.

Неоднородная часть f(n) = 3ⁿ. Аннигилятор L₂ = E - 3.

Общий аннигилятор L = L₂ L₁ = (E-3)(E-2).

Решаем L[aₙ]=0 => (E-3)(E-2)[aₙ]=0 => aₙ - 5aₙ₋₁ + 6aₙ₋₂ = 0. Хар. ур-е: r² - 5r + 6=0, корни r₁=2, r₂=3. Общее решение: aₙ = A*2ⁿ + B*3ⁿ.

Начальное условие a₀=1: A*2⁰ + B*3⁰ = A + B = 1.
Условие из исходной рекурренты при n=1: a₁ - 2a₀ = 3¹ => a₁ - 2*1 = 3 => a₁ = 5.
a₁= A*2¹ + B*3¹ = 2A + 3B = 5.
Решаем систему: A+B=1, 2A+3B=5 => A=-2, B=3.

Решение: aₙ = -2 * 2ⁿ + 3 * 3ⁿ = 3ⁿ⁺¹ - 2ⁿ⁺¹.

## 37. Числа Каталана (Catalan numbers) - Повтор, см. п.28.

## 38. Анализ алгоритмов "Разделяй и властвуй" с помощью рекурсивных деревьев

Суть: Метод визуализации рекурсивных вызовов алгоритма для анализа его временной сложности T(n), заданной рекуррентным соотношением.

Алгоритм:

Построить дерево, где:

Корень представляет вызов алгоритма на входе размера n.

Сыновья корня представляют рекурсивные вызовы на подзадачах размера n/b (или близких размеров).

Каждый узел помечен работой, выполненной на данном уровне рекурсии (без учета рекурсивных вызовов), то есть f(n) из рекурренты T(n) = aT(n/b) + f(n).

Суммировать работу на каждом уровне дерева:

Уровень 0 (корень): Работа = f(n)

Уровень 1: a узлов, каждый с работой f(n/b) => Работа = a * f(n/b)

Уровень 2: a² узлов, каждый с работой f(n/b²) => Работа = a² * f(n/b²)

...

Уровень i: aⁱ узлов, каждый с работой f(n/bⁱ) => Работа = aⁱ * f(n/bⁱ)

Найти число уровней: Подзадачи уменьшаются в b раз на каждом уровне. Размер подзадачи на уровне i: n/bⁱ. Размер становится 1 (базовый случай) при n/bⁱ = 1 => i = log_b(n). Значит, всего уровней: log_b(n) + 1 (включая корень).

Общая работа: T(n) = Σ_{i=0}^{log_b n} [ aⁱ * f(n/bⁱ) ]

Применение: Позволяет вывести асимптотику T(n) (Θ, O, Ω) путем оценки суммы. Полезно, когда нельзя применить основную теорему.

## 39. Основная теорема (Master theorem)

Суть: "Поваренная книга" для быстрого определения асимптотики решений широкого класса рекуррентностей вида T(n) = aT(n/b) + f(n), где a ≥ 1, b > 1 - константы, f(n) - асимптотически положительная функция.

Формулировка: Сравниваем f(n) с n^{log_b a}.

Случай 1: Если f(n) = O(n^{log_b a - ε}) для некоторой константы ε > 0, то T(n) = Θ(n^{log_b a}).

Случай 2: Если f(n) = Θ(n^{log_b a} logᵏ n) для некоторой константы k ≥ 0, то T(n) = Θ(n^{log_b a} logᵏ⁺¹ n).

Важный подслучай (k=0): Если f(n) = Θ(n^{log_b a}), то T(n) = Θ(n^{log_b a} log n).

Случай 3: Если f(n) = Ω(n^{log_b a + ε}) для некоторой константы ε > 0, и если выполняется условие регулярности a·f(n/b) ≤ c·f(n) для некоторой константы c < 1 и всех достаточно больших n, то T(n) = Θ(f(n)).

Примеры:

T(n) = 2T(n/2) + n: a=2, b=2, log_b a=1, f(n)=n=Θ(n¹)=Θ(n^{log_b a}) => Случай 2 (k=0) => T(n)=Θ(n log n).

T(n) = 8T(n/2) + n³: a=8, b=2, log₂8=3, f(n)=n³=Θ(n³)=Θ(n^{log_b a}) => Случай 2 (k=0) => T(n)=Θ(n³ log n).

T(n) = T(n/2) + 1: a=1, b=2, log₂1=0, f(n)=1=Θ(n⁰)=Θ(n^{log_b a}) => Случай 2 (k=0) => T(n)=Θ(log n).

T(n) = 3T(n/4) + n log n: a=3, b=4, log₄3 ≈ 0.793, f(n)=n log n. n log n = Ω(n) = Ω(n^{log₄3 + ε}) для ε≈0.2? Да. Проверим условие регулярности: a·f(n/b)=3*(n/4)*log(n/4) = (3/4)n (log n - 2) ≤ c * n log n = f(n) для c=3/4 <1 и больших n. => Случай 3 => T(n)=Θ(n log n).

## 40. Метод Акра-Бацци (Akra–Bazzi method)

Суть: Обобщение основной теоремы на рекуррентности вида:
T(n) = Σ_{i=1}^{k} aᵢ T(bᵢn + hᵢ(n)) + f(n)
где:

aᵢ > 0 (константы)

0 < bᵢ < 1 (константы)

|hᵢ(n)| = O(n / log² n) ("малые" возмущения размеров подзадач)

f(n) - допустимая функция (обычно полином, полиномиальный логарифм, полином от логарифма).

Алгоритм:

Найти p: Найти единственное действительное число p, удовлетворяющее уравнению: Σ_{i=1}^{k} aᵢ bᵢᵖ = 1.

Решение: T(n) = Θ( nᵖ ( 1 + ∫₁ⁿ (f(u) / u^{p+1}) du ) ).

Примеры:

T(n) = T(n/2) + T(n/3) + n: a₁=1, b₁=1/2; a₂=1, b₂=1/3; f(n)=n.
Уравнение для p: (1/2)^p + (1/3)^p = 1. p≈0.787 (находится численно).
Интеграл: ∫₁ⁿ (u / u^{p+1}) du = ∫₁ⁿ u^{-p} du = [ u^{1-p}/(1-p) ]₁ⁿ = (n^{1-p} - 1)/(1-p) = Θ(n^{1-p}).
Решение: T(n) = Θ( n^p (1 + Θ(n^{1-p})) ) = Θ( n^p * n^{1-p} ) = Θ(n).

T(n) = 2T(n/2) + n / log n: a₁=2, b₁=1/2; f(n)=n / log n.
Уравнение для p: 2*(1/2)^p = 1 => (1/2)^{p-1} = 1 => p-1=0 => p=1.
Интеграл: ∫₁ⁿ ( (u / log u) / u^{1+1} ) du = ∫₁ⁿ (1 / (u log u)) du = [ ln |ln u| ]₁ⁿ = ln ln n - ln ln 1 → ∞ (расходится).
Решение: T(n) = Θ( n (1 + ln ln n) ) = Θ(n log log n).
